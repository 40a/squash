// Code generated by go-swagger; DO NOT EDIT.

package debugattachment

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new debugattachment API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for debugattachment API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddDebugAttachment requests squash to attach to a running container

A debug attachment instructs squash to attach to a container. Debug attachment is made of
  - image: The container image we are debugging. this is used for extra validation, as placing breakpoints on the wrong binary can lead to unexpected results. if not provided huerisrtics will be used to identify it.
  - debugger: Type of debugger to use. "dlv" and "gdb" are supported now.
  - match_request: Whether to match this attachment to a debug request. This is used in automated use-cases to guarantee that the attachment will be noticed.

*/
func (a *Client) AddDebugAttachment(params *AddDebugAttachmentParams) (*AddDebugAttachmentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddDebugAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addDebugAttachment",
		Method:             "POST",
		PathPattern:        "/debugattachment",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AddDebugAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddDebugAttachmentCreated), nil

}

/*
DeleteDebugAttachment deletes a debug attachment

Delete a debug attachment. be careful not to delete on during attaching phase.
*/
func (a *Client) DeleteDebugAttachment(params *DeleteDebugAttachmentParams) (*DeleteDebugAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDebugAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDebugAttachment",
		Method:             "DELETE",
		PathPattern:        "/debugattachment/{debugAttachmentId}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteDebugAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDebugAttachmentOK), nil

}

/*
GetDebugAttachment returns a debug attachment

Return a debug attachment
*/
func (a *Client) GetDebugAttachment(params *GetDebugAttachmentParams) (*GetDebugAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDebugAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDebugAttachment",
		Method:             "GET",
		PathPattern:        "/debugattachment/{debugAttachmentId}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDebugAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDebugAttachmentOK), nil

}

/*
GetDebugAttachments returns all debug attachment

Return all debug attachment
*/
func (a *Client) GetDebugAttachments(params *GetDebugAttachmentsParams) (*GetDebugAttachmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDebugAttachmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDebugAttachments",
		Method:             "GET",
		PathPattern:        "/debugattachment",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDebugAttachmentsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDebugAttachmentsOK), nil

}

/*
PatchDebugAttachment modifies an existing attachment

Modify an existing attachment.

*/
func (a *Client) PatchDebugAttachment(params *PatchDebugAttachmentParams) (*PatchDebugAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchDebugAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchDebugAttachment",
		Method:             "PATCH",
		PathPattern:        "/debugattachment/{debugAttachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchDebugAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchDebugAttachmentOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
