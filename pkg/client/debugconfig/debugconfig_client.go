package debugconfig

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new debugconfig API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for debugconfig API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddDebugConfig adds a new debug configuration for squash server

Add a debug config to squash. A debug config instrucs squash what containers should be debugged, and now. DebugConfig object consists of:
  - Attachment: The object we are attaching to. either a specific container, or a service.
  in the case of the service, the squash will attach to the first container that hits a debug event.
  - Breakpoints: A list of breakpoints. When "immediately" set to false, squash will wait for a debug event
  (i.e a program crash) before giving the user access to the remote debugger. If breakpoints is set, squash will place them and will notify when the first breakpoint hits.
  - image: The container image we are debugging. this is used for extra validation, as placing breakpoints on the wrong binary can lead to unexpected results.
  - debugger: Type of debugger to use. "dlv" and "gdb" are supported now.
  - immediately: Weather to attach immediatly or wait for debug event. can only be set to true if attachment type is container.

*/
func (a *Client) AddDebugConfig(params *AddDebugConfigParams) (*AddDebugConfigCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddDebugConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addDebugConfig",
		Method:             "POST",
		PathPattern:        "/debugconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AddDebugConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddDebugConfigCreated), nil

}

/*
DeleteDebugConfig deletes a debug config

Delete a debug config
*/
func (a *Client) DeleteDebugConfig(params *DeleteDebugConfigParams) (*DeleteDebugConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDebugConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDebugConfig",
		Method:             "DELETE",
		PathPattern:        "/debugconfig/{debugConfigId}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteDebugConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDebugConfigOK), nil

}

/*
GetDebugConfig retruns a debug config

Retrun a debug config
*/
func (a *Client) GetDebugConfig(params *GetDebugConfigParams) (*GetDebugConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDebugConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDebugConfig",
		Method:             "GET",
		PathPattern:        "/debugconfig/{debugConfigId}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDebugConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDebugConfigOK), nil

}

/*
GetDebugConfigs retruns all debug configs

Retrun all debug configs
*/
func (a *Client) GetDebugConfigs(params *GetDebugConfigsParams) (*GetDebugConfigsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDebugConfigsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDebugConfigs",
		Method:             "GET",
		PathPattern:        "/debugconfig",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDebugConfigsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDebugConfigsOK), nil

}

/*
PopContainerToDebug pops the latest debugconfig for a node in the cluster this is used by the squash client
*/
func (a *Client) PopContainerToDebug(params *PopContainerToDebugParams) (*PopContainerToDebugOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPopContainerToDebugParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "popContainerToDebug",
		Method:             "DELETE",
		PathPattern:        "/debugconfig/platform/containers/{node}/latest",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PopContainerToDebugReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PopContainerToDebugOK), nil

}

/*
UpdateDebugConfig updates an existing debug config
*/
func (a *Client) UpdateDebugConfig(params *UpdateDebugConfigParams) (*UpdateDebugConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDebugConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateDebugConfig",
		Method:             "PATCH",
		PathPattern:        "/debugconfig/{debugConfigId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateDebugConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateDebugConfigOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
